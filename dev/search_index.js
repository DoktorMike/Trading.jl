var documenterSearchIndex = {"docs":
[{"location":"portfolio/#Portfolio","page":"Portfolio","title":"Portfolio","text":"","category":"section"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"CurrentModule=Trading","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"The functionality here can be pulled into the namespace by","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"using Trading.Portfolio","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"A portfolio is represented by a combination of components:","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"Cash: the real cash balance of the portfolio, updated as Orders get filled, see current_cash\nPosition: represents a held quantity of an asset. current_position can be used as an easy way to retrieve the position size.\nPurchasePower: can be used to determine whether certain orders can be made, see current_purchasepower. At the start of every cycle this gets equalized with the current Cash, can be used as an estimation of \"future\" cash if certain orders would get executed.\nPortfolioSnapshot: a periodical snapshot of the portfolio","category":"page"},{"location":"portfolio/#Orders","page":"Portfolio","title":"Orders","text":"","category":"section"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"The state of the portfolio can be changed by using:","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"Purchase: communicates to the system that a purchase order should be made. Will be executed by the Seller system.\nSale: communicates that a sale order should be made. Will be executed by the Purchaser system.","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"Each order can have an OrderType, which defaults to OrderType.Market and a TimeInForce which defaults to TimeInForce.GTC (good till canceled). A price can be specified for orders that are not a Market order.","category":"page"},{"location":"portfolio/#Example","page":"Portfolio","title":"Example","text":"","category":"section"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"We first construct a Trader which we start without any strategies.","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"broker = AlpacaBroker(\"<key_id>\", \"<secret>\")\n\ntrader = Trader(broker)\n\nstart(trader)","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"Now we can interact with it and do some basic trades. First we ask for a Market order on AAPL","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"e = Entity(trader, Purchase(\"AAPL\", 1))","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"After a while e will have a Filled component, signalling that the order was executed succesfully, and","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"current_position(trader, \"AAPL\")","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"will return 1.0.","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"We can do the exact same to make a Sale.","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"e = Entity(trader, Sale(\"AAPL\", 1))\ncurrent_position(trader, \"AAPL\") # now 0","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"note: Note\nShorting is allowed","category":"page"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"For different options and order types see OrderType and TimeInForce","category":"page"},{"location":"portfolio/#References","page":"Portfolio","title":"References","text":"","category":"section"},{"location":"portfolio/","page":"Portfolio","title":"Portfolio","text":"Trading.current_position\nTrading.current_cash\nTrading.current_purchasepower\nTrading.Cash\nTrading.PurchasePower\nTrading.Position\nTrading.Purchase\nTrading.Sale\nTrading.Order\nTrading.Filled\nTrading.PortfolioSnapshot\nTrading.OrderType\nTrading.TimeInForce\nTrading.Purchaser\nTrading.Seller\nTrading.Filler\nTrading.DayCloser\nTrading.SnapShotter","category":"page"},{"location":"portfolio/#Trading.current_position","page":"Portfolio","title":"Trading.current_position","text":"current_position(trader, ticker::String)\n\nReturns the current portfolio position for ticker. Returns nothing if ticker is not found in the portfolio.\n\n\n\n\n\n","category":"function"},{"location":"portfolio/#Trading.current_cash","page":"Portfolio","title":"Trading.current_cash","text":"current_cash(trader)\n\nReturns the current cash balance of the trader.\n\n\n\n\n\n","category":"function"},{"location":"portfolio/#Trading.current_purchasepower","page":"Portfolio","title":"Trading.current_purchasepower","text":"current_purchasepower(trader)\n\nReturns the current PurchasePower.\n\n\n\n\n\n","category":"function"},{"location":"portfolio/#Trading.Cash","page":"Portfolio","title":"Trading.Cash","text":"Cash\n\nRepresents the actual cash balance. Currently there is no particular currency tied to this.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.PurchasePower","page":"Portfolio","title":"Trading.PurchasePower","text":"PurchasePower\n\nRepresents the current purchasing power. This is updated at the start of each update cycle to the current value of the Cash singleton. It can thus be used to determine how many purchases/trades can be made during one cycle.  \n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Position","page":"Portfolio","title":"Trading.Position","text":"Position\n\nRepresents a position held in an equity represented by ticker.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Purchase","page":"Portfolio","title":"Trading.Purchase","text":"Purchase(ticker, quantity;\n         type          = OrderType.Market,\n         time_in_force = TimeInForce.GTC,\n         price         = 0.0,\n         trail_percent = 0.0)\n\nThe local representation of a purchase order. This will be turned into an Order by the Purchaser System as soon as it's communicated to the broker. See OrderType and TimeInForce for more information on those kwargs.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Sale","page":"Portfolio","title":"Trading.Sale","text":"Sale(ticker, quantity;\n         type          = OrderType.Market,\n         time_in_force = TimeInForce.GTC,\n         price         = 0.0,\n         trail_percent = 0.0)\n\nThe local representation of a sell order. This will be turned into an Order by the Seller System as soon as it's communicated to the broker. See OrderType and TimeInForce for more information on those kwargs.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Order","page":"Portfolio","title":"Trading.Order","text":"Order\n\nRepresentation of a Purchase or Sale order that has been communicated to the broker. Once the status goes to \"filled\" the filling information will be taken by the Filler System to create a Filled component. \n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Filled","page":"Portfolio","title":"Trading.Filled","text":"Filled\n\nRepresents the filled avg_price and quantity of an Order.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.PortfolioSnapshot","page":"Portfolio","title":"Trading.PortfolioSnapshot","text":"PortfolioSnapshot\n\nA snapshot of the current Positions and Cash value of the portfolio.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.OrderType","page":"Portfolio","title":"Trading.OrderType","text":"Enum representing the different kinds of orders that can be made.\n\nMarket\nLimit\nStop\nStopLimit\nTrailinStop\n\n\n\n\n\n","category":"module"},{"location":"portfolio/#Trading.TimeInForce","page":"Portfolio","title":"Trading.TimeInForce","text":"Enum representing the lifetime of an order.\n\nDay: till the end of the trading day\nGTC: good till canceled\nOPG: executed on market open\nCLS: executed at market close\nIOC: immediate or canceled, any unfilled part of the order will be canceled\nFOK: executed only when the full quantity can be filled, otherwise canceled.\n\n\n\n\n\n","category":"module"},{"location":"portfolio/#Trading.Purchaser","page":"Portfolio","title":"Trading.Purchaser","text":"Purchaser\n\nHandles Purchases. Mainly verifies prices and quantities to be purchased.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Seller","page":"Portfolio","title":"Trading.Seller","text":"Seller\n\nHandles Sales.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.Filler","page":"Portfolio","title":"Trading.Filler","text":"Filler\n\nWhen the status of an Order changes to \"filled\", the filled quantity and average fill price is  registered in a Filled Component.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.DayCloser","page":"Portfolio","title":"Trading.DayCloser","text":"DayCloser([interval::Period = Minute(1)])\n\nCloses the day. Will run during the time interval [market_close - interval, market_close]. Currently it just removes pending trades.\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#Trading.SnapShotter","page":"Portfolio","title":"Trading.SnapShotter","text":"SnapShotter([interval::Period = Minute(1)])\n\nTakes a PortfolioSnapshot after each interval, storing Positions, Cash, and total value.\n\n\n\n\n\n","category":"type"},{"location":"strategies/#Strategies","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = Trading","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"As with any other functionality in Trading, Strategies are represented by Systems and thus are treated on completely equal footing with the core functionality. There are three main parts that need to be implemented for a Strategy to be used: the struct, the Overseer.update function, and the Overseer.requested_components function. This latter one will be used to determine which Indicator systems need to be running on the TickerLedgers in order to produce the Indicators that are used by the Strategy. The update function of a Strategy System is ran periodically after the update functions for the other Systems that make the rest of the Trader tick.","category":"page"},{"location":"strategies/#Strategy-Definition","page":"Tutorial","title":"Strategy Definition","text":"","category":"section"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"As an example we will implement a very simple slow/fast moving average strategy, i.e. SlowFast. The goal is that we can later use it in our Trader in to following way:","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"trader = Trader(broker; strategies = [Strategy(:slowfast, [SlowFast()], tickers=[\"stock1\", \"stock2\"])])","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We begin by defining the SlowFast System and the components that it requests to be present in TickerLedgers. They will be automatically created as tick data arrives.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"using Trading#hide\nusing Trading.Strategies#hide\nusing Trading.Basic#hide\nusing Trading.Indicators#hide\nusing Trading.Portfolio#hide\nstruct SlowFast <: System end\n\nOverseer.requested_components(::SlowFast) = (SMA{50, Close}, SMA{200, Close})","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We here request the slow and fast sma components of the closing price (SMA{200, Trading.Close}, SMA{50, Trading.Close}).","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We then implement the following update function that will be executed periodically:","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"function Overseer.update(s::SlowFast, t::Trader, ticker_ledgers)\n    for ticker_ledger in ticker_ledgers\n\n        ticker = ticker_ledger.ticker\n\n        for e in new_entities(ticker_ledger, s)\n            lag_e = lag(e, 1)\n\n            if lag_e === nothing\n                continue\n            end\n\n            sma_50  = e[SMA{50, Close}].sma\n            sma_200 = e[SMA{200, Close}].sma\n            \n            lag_sma_50 = lag_e[SMA{50, Close}].sma\n            lag_sma_200 = lag_e[SMA{200, Close}].sma\n\n            if sma_50 > sma_200 && lag_sma_50 < lag_sma_200\n                Entity(t, Sale(ticker, 1.0))\n            elseif sma_50 < sma_200 && lag_sma_50 > lag_sma_200\n                Entity(t, Purchase(ticker, 1.0))\n            end\n\n        end\n    end\nend","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"Let's go through this line by line:","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"for ticker_ledger in ticker_ledgers","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We loop through each of the ticker ledgers that this strategy was created for (i.e. stock1, stock2).","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"for e in new_entities(ticker_ledger, s)","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"Then, we ask for the new_entities in the TickerLedger that have in this case both the SMA{200, Close} and SMA{50,Close} components. Each of these entities will be touched once and only once.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"lag_e = lag(e, 1)","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"Since we are looking for crossings between the two moving averages, we ask for the entity of the previous time. If there was none, i.e. e is the very first entity, lag(e, 1) will return nothing and so we don't do anything.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"sma_50  = e[SMA{50, Close}].sma\nsma_200 = e[SMA{200, Close}].sma\n\nlag_sma_50 = lag_e[SMA{50, Close}].sma\nlag_sma_200 = lag_e[SMA{200, Close}].sma","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We retrieve the sma's for both the current and lagged entity.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"if sma_50 > sma_200 && lag_sma_50 < lag_sma_200\n    Entity(t, Sale(ticker, 1.0))\nelseif sma_50 < sma_200 && lag_sma_50 > lag_sma_200\n    Entity(t, Purchase(ticker, 1.0))\nend","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"If the fast sma crosses above the slow sma, we assume the stock is overbought and we sell it by creating an Entity with a  Sale component. Vice versa, If the fast sma crosses below the slow sma, we assume the stock is oversold and we buy it by creating an Entity with a  Purchase component.","category":"page"},{"location":"strategies/#BackTesting","page":"Tutorial","title":"BackTesting","text":"","category":"section"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"The framework is set up to treat backtesting and realtime trading in completely identical ways, and we can therefore backtest our strategy on some historical data.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We first define the broker from which to pull the historical data, in this case we use AlpacaBroker with our key_id and secret. We then use it in the HistoricalBroker which supplies data in the same way of a realtime broker would.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We then set up the strategy for the MSFT and AAPL tickers, define our BackTester with our data range and interval dt.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"note: Note\nWhen using daily data (e.g. dt=Day(1)), it is important to specify only_day=false, otherwise nothing will happen since our strategy will only run during trading hours, and no daily bars will have a timestamp inside those hours.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"Finally we use start to loop through all the days and execute the strategy, possible trades, and any other behavior as if it is realtime.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"broker = HistoricalBroker(AlpacaBroker(ENV[\"ALPACA_KEY_ID\"], ENV[\"ALPACA_SECRET\"]))\n\nstrategy = Strategy(:slowfast, [SlowFast()], tickers=[\"MSFT\", \"AAPL\"])\n\ntrader = BackTester(broker, start = DateTime(\"2015-01-01T00:00:00\"),\n                            stop = DateTime(\"2020-01-01T00:00:00\"),\n                            dt = Day(1),\n                            strategies = [strategy],\n                            cash = 1000,\n                            only_day=false)\nstart(trader)","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"To perform further analysis we can transform the trader data into a standard TimeArray as:","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"ta = TimeArray(trader)","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"by using Plots we can then plot certain columns in the TimeArray, e.g. the portfolio value:","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"using Plots\nplot(ta[:value])","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"We can see that this strategy is not particularly succesful.","category":"page"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"See Slow Fast Strategy for a full runnable version of this strategy.","category":"page"},{"location":"strategies/#References","page":"Tutorial","title":"References","text":"","category":"section"},{"location":"strategies/","page":"Tutorial","title":"Tutorial","text":"Trading.new_entities\nTrading.start\nTrading.reset!","category":"page"},{"location":"strategies/#Trading.new_entities","page":"Tutorial","title":"Trading.new_entities","text":"new_entities(ledger, strategy)\n\nReturns a NewEntitiesIterator which iterates through the entities that have components that are requested by strategy, and were not yet seen. I.e. each entity in those components will be looped over once and only once when iteratively calling new_entities.\n\n\n\n\n\n","category":"function"},{"location":"strategies/#Trading.start","page":"Tutorial","title":"Trading.start","text":"start(trader)\n\nStarts the loop of a Trader or BackTester.\n\n\n\n\n\n","category":"function"},{"location":"strategies/#Trading.reset!","page":"Tutorial","title":"Trading.reset!","text":"reset!(trader)\n\nResets a Trader to the starting point. Usually only used on a BackTester.\n\n\n\n\n\n","category":"function"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"EditURL = \"https://github.com/louisponet/Trading.jl/blob/master/docs/src/strategies/slow_fast.jl\"","category":"page"},{"location":"strategies/slow_fast/#slow_fast_id","page":"Slow Fast","title":"Slow Fast Moving Average","text":"","category":"section"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"using Trading\nusing Trading.Strategies\nusing Trading.Basic\nusing Trading.Indicators\nusing Trading.Portfolio\n\nstruct SlowFast <: System end\nOverseer.requested_components(::SlowFast) = (SMA{50, Close}, SMA{200, Close})\n\nfunction Overseer.update(s::SlowFast, t::Trader, ticker_ledgers)\n    for ticker_ledger in ticker_ledgers\n        ticker = ticker_ledger.ticker\n        for e in new_entities(ticker_ledger, s)\n            lag_e = lag(e, 1)\n\n            if lag_e === nothing\n                continue\n            end\n\n            sma_50  = e[SMA{50, Close}].sma\n            sma_200 = e[SMA{200, Close}].sma\n\n            lag_sma_50 = lag_e[SMA{50, Close}].sma\n            lag_sma_200 = lag_e[SMA{200, Close}].sma\n\n            if sma_50 > sma_200 && lag_sma_50 < lag_sma_200\n                Entity(t, Sale(ticker, 1.0))\n            elseif sma_50 < sma_200 && lag_sma_50 > lag_sma_200\n                Entity(t, Purchase(ticker, 1.0))\n            end\n        end\n    end\nend","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"The Inf values for the quantity of stocks to trade in the Sale and Purchase constructors signifies that we want to buy as many stocks as our cash balance allows for.","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"broker = HistoricalBroker(AlpacaBroker(ENV[\"ALPACA_KEY_ID\"], ENV[\"ALPACA_SECRET\"]))\n\nstrategy = Strategy(:slowfast, [SlowFast()], tickers=[\"MSFT\", \"AAPL\"])\n\ntrader = BackTester(broker, start = DateTime(\"2015-01-01T00:00:00\"),\n                            stop = DateTime(\"2020-01-01T00:00:00\"),\n                            dt = Day(1),\n                            strategies = [strategy],\n                            cash = 1000,\n                            only_day=false)\nstart(trader)","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"After having executed the strategy, we can see some quick overview from the output, but by converting it to a TimeArray we can more easily analyse how the strategy performed","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"using Plots\n\nta = TimeArray(trader)\n\nplot(ta[:value])","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"We see that in this case the strategy didn't work particularly well. In fact it seems that inverting it, we might get a better result. We can simply redefine our update function as follows:","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"function Overseer.update(s::SlowFast, t::Trader, ticker_ledgers)\n    for ticker_ledger in ticker_ledgers\n        ticker = ticker_ledger.ticker\n        for e in new_entities(ticker_ledger, s)\n            lag_e = lag(e, 1)\n\n            if lag_e === nothing\n                continue\n            end\n\n            sma_50  = e[SMA{50, Close}].sma\n            sma_200 = e[SMA{200, Close}].sma\n\n            lag_sma_50 = lag_e[SMA{50, Close}].sma\n            lag_sma_200 = lag_e[SMA{200, Close}].sma\n\n            if sma_50 > sma_200 && lag_sma_50 < lag_sma_200\n                Entity(t, Purchase(ticker, Inf))\n            elseif sma_50 < sma_200 && lag_sma_50 > lag_sma_200\n                Entity(t, Sale(ticker, Inf))\n            end\n        end\n    end\nend","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"We have basically swapped the Purchase and Sale components. To execute this updated version we call reset! and start again.","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"reset!(trader)\nstart(trader)","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"and plot the results again, this time taking the relative performances of the portfolio vs the two stocks:","category":"page"},{"location":"strategies/slow_fast/","page":"Slow Fast","title":"Slow Fast","text":"ta = TimeArray(trader)\n\nportfolio_val = ta[:value]./values(ta[:value])[1]\naapl_closes = ta[:AAPL_Close] ./ values(ta[:AAPL_Close])[1]\nmsft_closes = ta[:MSFT_Close] ./ values(ta[:MSFT_Close])[1]\n\nplot(merge(portfolio_val, aapl_closes, msft_closes))","category":"page"},{"location":"installation/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"CurrentModule=Trading","category":"page"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"Since the package is registered, you can simply install it using","category":"page"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"Trading\")","category":"page"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"After this, it is recommended to set up a Broker. For the moment only Alpaca is supported, and to make the API work, you'll need to generate a set of api keys.","category":"page"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"Then you can create an AlpacaBroker and you're good to go.","category":"page"},{"location":"installation/","page":"Getting Started","title":"Getting Started","text":"See the strategies tutorial to continue with creating and backtesting a strategy.","category":"page"},{"location":"data/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"CurrentModule=Trading","category":"page"},{"location":"data/#Historical","page":"Data","title":"Historical","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"The current suggested method of historical data acquisition is through the AlpacaBroker. There are three types of data that can be retrieved: bars, quotes and trades.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"bars\nquotes\ntrades","category":"page"},{"location":"data/#Trading.bars","page":"Data","title":"Trading.bars","text":"bars(broker, ticker, start, stop; timeframe, kwargs...)\n\nRetrieve the bar data for ticker from start to stop and with an interval of timeframe. When using AlpacaBroker see the Bar Object documentation for further reference.\n\nExample\n\nbroker = AlpacaBroker(<key_id>, <secret_key>)\n\nbars(broker, \"AAPL\",\n     DateTime(\"2022-01-01T00:00:00\"),\n     DateTime(\"2023-01-01T00:00:00\"),\n     timeframe = Minute(1))\n\nThe above will retrieve 2022 bar data \"AAPL\" on a Minute resolution. \n\n\n\n\n\n","category":"function"},{"location":"data/#Trading.quotes","page":"Data","title":"Trading.quotes","text":"quotes(broker, ticker, start, stop)\n\nReturns the quotes made for ticker between start and stop. When using AlpacaBroker see the Quote Object documentation for further reference.\n\nExample\n\nbroker = AlpacaBroker(<key_id>, <secret_key>)\n\nquotes(broker, \"AAPL\", DateTime(\"2022-01-01T14:30:00\"), DateTime(\"2022-01-01T14:31:00\"))\n\n\n\n\n\n","category":"function"},{"location":"data/#Trading.trades","page":"Data","title":"Trading.trades","text":"trades(broker, ticker, start, stop)\n\nReturns the trades made for ticker between start and stop. When using AlpacaBroker see the Trade Object documentation for further reference.\n\nExample\n\nbroker = AlpacaBroker(<key_id>, <secret_key>)\n\ntrades(broker, \"AAPL\", DateTime(\"2022-01-01T14:30:00\"), DateTime(\"2022-01-01T14:31:00\"))\n\n\n\n\n\n","category":"function"},{"location":"data/","page":"Data","title":"Data","text":"Each of these will return a TimeArray, which can be used e.g. with MarketTechnicals for specialized analysis. An AbstractBroker has an internal cache that will retain previously requested data.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Trading.OrderStream\nTrading.order_stream","category":"page"},{"location":"data/#Trading.OrderStream","page":"Data","title":"Trading.OrderStream","text":"OrderStream\n\nInterface to support executing trades and retrieving account updates.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.order_stream","page":"Data","title":"Trading.order_stream","text":"order_stream(f::Function, broker::AbstractBroker)\n\nCreates an OrderStream to stream order data. Uses the same semantics as a standard HTTP.WebSocket.\n\nExample\n\nbroker = AlpacaBroker(<key_id>, <secret_key>)\n\norder_stream(broker) do stream\n    order = receive(stream)\nend\n\n\n\n\n\n","category":"function"},{"location":"data/#Ticker-Ledgers","page":"Data","title":"Ticker Ledgers","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Trading.TickerLedger","category":"page"},{"location":"data/#Trading.TickerLedger","page":"Data","title":"Trading.TickerLedger","text":"TickerLedger\n\nA TickerLedger holds the data for a given ticker as it arrives. Currently this is bar data in the form of Open, High, Low, Close and Volume, produced by a BarStream. If certain derived Indicator data is requested, it also holds this as it is produced by the different systems.\n\n\n\n\n\n","category":"type"},{"location":"data/#Bar-Components","page":"Data","title":"Bar Components","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Bars are represented internally by the following set of Components. Basically they are the standard ohlc and a volume components.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Trading.Open\nTrading.High\nTrading.Low\nTrading.Close\nTrading.Volume","category":"page"},{"location":"data/#Trading.Open","page":"Data","title":"Trading.Open","text":"Open\n\nThe opening price of a given bar.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.High","page":"Data","title":"Trading.High","text":"High\n\nThe highest price of a given bar.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.Low","page":"Data","title":"Trading.Low","text":"Low\n\nThe lowest price of a given bar.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.Close","page":"Data","title":"Trading.Close","text":"Close\n\nThe closing price of a given bar.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.Volume","page":"Data","title":"Trading.Volume","text":"Volume\n\nThe traded volume of a given bar.\n\n\n\n\n\n","category":"type"},{"location":"data/","page":"Data","title":"Data","text":"Bars are streamed by a BarStream, either in realtime from a realtime broker (e.g. AlpacaBroker), or faked realtime when using a HistoricalBroker.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Trading.BarStream\nTrading.bar_stream\nTrading.HTTP.receive(b::Trading.BarStream)\nTrading.register!(b::Trading.BarStream, ticker)","category":"page"},{"location":"data/#Trading.BarStream","page":"Data","title":"Trading.BarStream","text":"BarStream\n\nSupplies a stream of bars from a broker. Can be created by calling bar_stream on an AbstractBroker. See receive and register! for more information.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.bar_stream","page":"Data","title":"Trading.bar_stream","text":"bar_stream(f::Function, broker)\n\nOpen a bar stream, calls function f with a BarStream object. Call receive on the BarStream to get new bars streamed in, and register! to register tickers for which to receive bar updates for.\n\n\n\n\n\n","category":"function"},{"location":"data/#HTTP.WebSockets.receive-Tuple{Trading.BarStream}","page":"Data","title":"HTTP.WebSockets.receive","text":"receive(barstream)\n\nBlocking function which will return new bars as soon as they are available.\n\n\n\n\n\n","category":"method"},{"location":"data/#Trading.register!-Tuple{Trading.BarStream, Any}","page":"Data","title":"Trading.register!","text":"register!(barstream, ticker)\n\nRegister a ticker to the BarStream so that receive will also return updates with new bars for ticker.\n\n\n\n\n\n","category":"method"},{"location":"data/#Indicators","page":"Data","title":"Indicators","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Indicator data is generated from incoming bar data by the indicator systems as requested by the Strategy systems. Most of them have two type parameters designating the window or horizon of the indicator. For example the SMA{20, Close} closing price simple moving average indicator shows at a given timestamp the average of the closing prices of the 20 previous bars.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Accessing this data can be done through a Trader, e.g.:","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"trader = Trader(broker, tickers=[\"MSFT\"])\n\ntrader[\"MSFT\"][SMA{20, Close}]","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"provided that it was generated. See Strategies for more information.","category":"page"},{"location":"data/#Data-2","page":"Data","title":"Data","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Trading.SMA\nTrading.MovingStdDev\nTrading.EMA\nTrading.RSI\nTrading.Bollinger\nTrading.Sharpe","category":"page"},{"location":"data/#Trading.SMA","page":"Data","title":"Trading.SMA","text":"SMA{horizon, T}\n\nThe simple moving average of a value over a timeframe of horizon.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.MovingStdDev","page":"Data","title":"Trading.MovingStdDev","text":"MovingStdDev{horizon, T}\n\nThe moving standard deviation of a value over timeframe of horizon.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.EMA","page":"Data","title":"Trading.EMA","text":"EMA{horizon, T}\n\nThe exponential moving average of a value over timeframe of horizon.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.RSI","page":"Data","title":"Trading.RSI","text":"RSI{horizon, T}\n\nThe relative strength index of a value over timeframe of horizon.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.Bollinger","page":"Data","title":"Trading.Bollinger","text":"Bollinger{horizon, T}\n\nThe up and down Bollinger bands for a value, over a timeframe of horizon.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.Sharpe","page":"Data","title":"Trading.Sharpe","text":"Sharpe{horizon, T}\n\nThe sharpe ratio of a value over a timeframe horizon.\n\n\n\n\n\n","category":"type"},{"location":"data/#indicator_systems","page":"Data","title":"Systems","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Trading.SMACalculator\nTrading.MovingStdDevCalculator\nTrading.EMACalculator\nTrading.RSICalculator\nTrading.BollingerCalculator\nTrading.SharpeCalculator","category":"page"},{"location":"data/#Trading.SMACalculator","page":"Data","title":"Trading.SMACalculator","text":"SMACalculator\n\nCalculates the SMA of data.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.MovingStdDevCalculator","page":"Data","title":"Trading.MovingStdDevCalculator","text":"MovingStdDevCalculator\n\nCalculates the MovingStdDev of data.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.EMACalculator","page":"Data","title":"Trading.EMACalculator","text":"EMACalculator\n\nCalculates the EMA of data.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.RSICalculator","page":"Data","title":"Trading.RSICalculator","text":"RSICalculator\n\nCalculates the RSI of values.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.BollingerCalculator","page":"Data","title":"Trading.BollingerCalculator","text":"BollingerCalculator\n\nCalculates the Bollinger bands for data. The width parameter can be tuned, by default it is 2.0.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.SharpeCalculator","page":"Data","title":"Trading.SharpeCalculator","text":"SharpeCalculator\n\nCalculates the bare Sharpe ratio of data.\n\n\n\n\n\n","category":"type"},{"location":"data/#General-Data","page":"Data","title":"General Data","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Trading.SingleValIndicator\nTrading.LogVal\nTrading.Difference\nTrading.RelativeDifference\n\nTrading.LogValCalculator\nTrading.DifferenceCalculator\nTrading.RelativeDifferenceCalculator","category":"page"},{"location":"data/#Trading.SingleValIndicator","page":"Data","title":"Trading.SingleValIndicator","text":"SingleValIndicator\n\nA Component with a single value (usually v) that can be used by Indicator Systems to calculate various Indicators. If the single value is not stored in the v field of the Component, overload Trading.value.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.LogVal","page":"Data","title":"Trading.LogVal","text":"LogVal\n\nThe logarithm of a value.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.Difference","page":"Data","title":"Trading.Difference","text":"Difference\n\nThe lag 1 difference.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.RelativeDifference","page":"Data","title":"Trading.RelativeDifference","text":"RelativeDifference\n\nThe lag 1 relative difference.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.LogValCalculator","page":"Data","title":"Trading.LogValCalculator","text":"LogValCalculator\n\nCalculates the logarithms of data.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.DifferenceCalculator","page":"Data","title":"Trading.DifferenceCalculator","text":"DifferenceCalculator\n\nComputes the lag 1 differences of data values.\n\n\n\n\n\n","category":"type"},{"location":"data/#Trading.RelativeDifferenceCalculator","page":"Data","title":"Trading.RelativeDifferenceCalculator","text":"RelativeDifferenceCalculator\n\nCalculates the lag 1 RelativeDifference of data.\n\n\n\n\n\n","category":"type"},{"location":"data/","page":"Data","title":"Data","text":"Trading.value","category":"page"},{"location":"data/#Trading.value","page":"Data","title":"Trading.value","text":"value(b::SingleValIndicator)\n\nReturns the number that is stored in the SingleValIndicator. This is by default the v field.\n\n\n\n\n\n","category":"function"},{"location":"#Trading","page":"Home","title":"Trading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Trading","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to Trading.jl, a powerful algorithmic trading and backtesting package written in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It provides an easy-to-use framework for defining and executing trading strategies based on technical indicators, as well as backtesting these strategies on historical data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It builds on the ease of use, extensibility, inherent performance and elegance of the ECS (Entity-Component-System) paradigm, implemented through Overseer.jl, and keeps interoperability with the Julia ecosystem by interfacing with TimeSeries.jl.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Highly customizable and extensible by being based on ECS\nBacktesting and Realtime trading treated on completely equal footing\nSeveral built in indicators such as SMA, EMA, MovingStdDev, RSI and Bollinger\nInteraction with brokers such as Alpaca\nHigh performance, with backtesting on 100k data points within seconds","category":"page"},{"location":"#Illustrative-Example","page":"Home","title":"Illustrative Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To define a trading strategy, all you need to do is implement a Julia struct that subtypes System with an update function that defines the trading logic. The update function is called periodically by the framework and has access to tick data for the tickers that the strategy was created for, as well as any technical indicators requested by the strategy. The package includes several built-in technical indicators such as simple moving averages, relative strength index, and exponential moving averages. Users can also define their own custom indicators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct MyStrategy <: System end\n\nOverseer.requested_components(::MyStrategy) = (Open, Close, SMA{20, Close}, SMA{200, Close})\n\nfunction Overseer.update(s::MyStrategy, trader, ticker_ledgers)\n   for ledger in ticker_ledgers\n        for e in new_entities(ledger, s)\n            #Trading logic goes here\n        end\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"To execute a trading strategy in real-time, users can create a Trader object with the desired strategies, and connect it to a real-time data source through the different broker APIs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"broker = AlpacaBroker(\"<key_id>\", \"<secret>\")\nstrategy = Strategy(:my_strategy, [MyStrategy()], tickers=[\"AAPL\"])\ntrader = Trader(broker, strategies=[strategy])\nstart(trader)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to backtest a trading strategy on historical data, you can use BackTester instead of Trader with the desired data range, interval, and strategies. The BackTester will simulate the behavior of a realtime Trader on the specified data. Afterward, a TimeArray can be created with the data from the trader, and used for performance analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"trader = BackTester(HistoricalBroker(broker),\n                    strategies=[strategy],\n                    start = <start date>,\n                    stop  = <stop date>,\n                    dt = <data timeframe>)\nstart(trader)\nta = TimeArray(trader)\nusing Plots\nplot(ta[:value])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Trading.jl is designed to be flexible and customizable, allowing you to extend it with new technical indicators, trading strategies, and data sources.","category":"page"},{"location":"#Other-Packages","page":"Home","title":"Other Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TimeSeries\nMarketTechnicals\nTradingLogic\nMarketData","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"EditURL = \"https://github.com/louisponet/Trading.jl/blob/master/docs/src/strategies/cointegration.jl\"","category":"page"},{"location":"strategies/cointegration/#Cointegration","page":"Cointegration","title":"Cointegration","text":"","category":"section"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"Here we demonstrate the most basic form of Cointegration/statistical arbitrage by pair trading AAPL and MSFT","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"using Trading\nusing Trading.Strategies\nusing Trading.Basic\nusing Trading.Indicators\nusing Trading.Portfolio","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"First we define our strategy Systems and the additional components that we need.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"@component struct Spread <: Trading.SingleValIndicator{Float64}\n    v::Float64\nend\n\nstruct SpreadCalculator <: System\n    γ::NTuple{5,Float64} # 1 cointegration ratio per day of the week\nend\n\nOverseer.requested_components(::SpreadCalculator) = (LogVal{Close}, )\n\nstruct PairStrat{horizon} <: System\n    γ::NTuple{5,Float64} # 1 cointegration ratio per day of the week\n    z_thr::Float64 # Threshold of the z_score above or below which we enter positions\nend\nOverseer.requested_components(::PairStrat{horizon}) where {horizon} = (Spread, SMA{horizon, Spread},MovingStdDev{horizon, Spread})\n\n@component struct ZScore{T} <: Trading.SingleValIndicator{Float64}\n    v::T\nend","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"Subtyping the SingleValIndicator will allow the automatic calculation of the single moving average and moving standard deviation necessary for our strategy. It is also important to have .v as the value field. If this is undesired you can overload Trading.value for your component type.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"Next we specify the update functions. In this more complicated strategy, we need to keep track of the Spread between two tickers. To facilitate this notion of shared or combined data, a ledger will be automatically generated with the name of shared tickers separated by _, i.e. MSFT_AAPL in our current example. This combined ledger will be the last entry in the ticker_ledgers argument.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"function Overseer.update(s::SpreadCalculator, m::Trading.Trader, ticker_ledgers)\n\n    @assert length(ticker_ledgers) == 3 \"Pairs Strategy only implemented for 2 tickers at a time\"\n    combined_ledger = ticker_ledgers[end]\n\n    curt = current_time(m)\n\n    # We clear all data from the previous day at market open\n    if Trading.is_market_open(curt)\n        for l in ticker_ledgers[1:2]\n            reset!(l, s)\n        end\n    end\n\n    new_bars1 = new_entities(ticker_ledgers[1], s)\n    new_bars2 = new_entities(ticker_ledgers[2], s)\n\n    tickers = map(x->x.ticker, ticker_ledgers[1:2])\n    @assert length(new_bars1) == length(new_bars2) \"New bars differ for tickers $tickers\"\n\n    γ = s.γ[dayofweek(curt)]\n    for (b1, b2) in zip(new_bars1, new_bars2)\n        Entity(combined_ledger, Trading.TimeStamp(curt), Spread(b1.v - γ * b2.v))\n    end\n    update(combined_ledger)\nend\n\nfunction Overseer.update(s::PairStrat, m::Trading.Trader, ticker_ledgers)\n    curt = current_time(m)\n\n    # We clear all data from the previous day at market open\n    if Trading.is_market_open(curt)\n        reset!(ticker_ledgers[end], s)\n    end\n\n    cash = m[Trading.PurchasePower][1].cash\n    new_pos = false\n    pending_order = any(x -> x ∉ m[Filled], @entities_in(m, Purchase || Sale))\n\n    pending_order || !Trading.in_trading(curt) && return\n\n    z_comp = ticker_ledgers[end][ZScore{Spread}]\n\n    ticker1 = ticker_ledgers[1].ticker\n    ticker2 = ticker_ledgers[2].ticker\n\n    γ = s.γ[Trading.dayofweek(curt)]\n\n    for e in new_entities(ticker_ledgers[end], s)\n\n        v         = e.v\n        sma       = e.sma\n        σ         = e.σ\n        z_score   = (v - sma) / σ\n        z_comp[e] = ZScore{Spread}(z_score)\n\n        curpos1 = current_position(m, ticker1)\n        curpos2 = current_position(m, ticker2)\n\n        p1 = current_price(m, ticker1)\n        p2 = current_price(m, ticker2)\n\n        quantity2(n1) = round(Int, n1 * p1 * γ / p2)\n\n        in_bought_leg = curpos1 > 0\n        in_sold_leg = curpos1 < 0\n\n        new_pos && continue\n\n        if z_score < -s.z_thr&& (in_sold_leg || curpos1 == 0)\n            new_pos = true\n            if in_sold_leg\n                q = -2*curpos1\n            else\n                q = cash/p1\n            end\n            Entity(m, Purchase(ticker1, q))\n            Entity(m, Sale(ticker2, quantity2(q)))\n\n\n        elseif z_score > s.z_thr && (in_bought_leg || curpos1 == 0)\n            new_pos = true\n            if in_bought_leg\n                q = 2*curpos1\n            else\n                q = cash / p1\n            end\n            Entity(m, Purchase(ticker2, quantity2(q)))\n            Entity(m, Sale(ticker1, q))\n        end\n\n        lag_e = lag(e, 1)\n        lag_e === nothing && continue\n\n        if new_pos\n            continue\n        end\n\n        going_up = z_score - z_comp[lag_e].v > 0\n\n        if z_score > 0 && in_bought_leg && !going_up\n            Entity(m, Sale(ticker1, curpos1))\n            Entity(m, Purchase(ticker2, -curpos2))\n            new_pos = true\n        elseif z_score < 0 && in_sold_leg && going_up\n            Entity(m, Purchase(ticker1, -curpos1))\n            Entity(m, Sale(ticker2, curpos2))\n            new_pos = true\n        end\n    end\nend","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"As usual we then specify our broker for the backtest. We here show an advanced feature that allows one to specify transaction fees associated with trades. We here define a fee per traded share, but no fixed or variable transaction fees. See HistoricalBroker for more information.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"broker = HistoricalBroker(AlpacaBroker(ENV[\"ALPACA_KEY_ID\"], ENV[\"ALPACA_SECRET\"]))\n\nbroker.variable_transaction_fee = 0.0\nbroker.fee_per_share = 0.005\nbroker.fixed_transaction_fee = 0.0;\nnothing #hide","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"Next we specify the daily cointegration parameters that were fit to 2022 data, and run the backtest on Minute data from the first 3 months of 2023.","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"γ = (0.83971041721211, 0.7802162996942561, 0.8150936011572303, 0.8665354500999517, 0.8253480013737815)\n\nstratsys = [SpreadCalculator(γ), PairStrat{20}(γ, 2.5)]\ntrader = BackTester(broker; strategies=[Strategy(:pair, stratsys, tickers=[\"MSFT\", \"AAPL\"])],\n                            start=TimeDate(\"2023-03-01T00:00:00\"),\n                            stop=TimeDate(\"2023-03-31T23:59:59\"))\n\nstart(trader)","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"We then can analyse our portfolio value","category":"page"},{"location":"strategies/cointegration/","page":"Cointegration","title":"Cointegration","text":"using Plots\nplot(TimeArray(trader)[:value])","category":"page"},{"location":"trader/#Trader","page":"Trader","title":"Trader","text":"","category":"section"},{"location":"trader/","page":"Trader","title":"Trader","text":"CurrentModule=Trading","category":"page"},{"location":"trader/","page":"Trader","title":"Trader","text":"Trading.Trader\nTrading.BackTester","category":"page"},{"location":"trader/#Trading.Trader","page":"Trader","title":"Trading.Trader","text":"Trader(broker::AbstractBroker; strategies::Vector{Pair{String, Vector{Strategy}}}, start=current_time())\n\nHolds all data and tasks related to trading. \n\n\n\n\n\n","category":"type"},{"location":"trader/#Trading.BackTester","page":"Trader","title":"Trading.BackTester","text":"BackTester(broker)\n\n\n\n\n\n","category":"function"},{"location":"trader/#Brokers","page":"Trader","title":"Brokers","text":"","category":"section"},{"location":"trader/","page":"Trader","title":"Trader","text":"Trading.AbstractBroker\nTrading.AlpacaBroker\nTrading.HistoricalBroker\nTrading.MockBroker","category":"page"},{"location":"trader/#Trading.AbstractBroker","page":"Trader","title":"Trading.AbstractBroker","text":"AbstractBroker\n\nInterface for external brokers.\n\n\n\n\n\n","category":"type"},{"location":"trader/#Trading.AlpacaBroker","page":"Trader","title":"Trading.AlpacaBroker","text":"AlpacaBroker\n\nBroker to communicate with Alpaca. Can be constructed with your key_id and secret_key (see connect-to-alpaca-api).\n\n\n\n\n\n","category":"type"},{"location":"trader/#Trading.HistoricalBroker","page":"Trader","title":"Trading.HistoricalBroker","text":"HistoricalBroker\n\nStores and provides data from historical datasets. Data can be streamed fashion by assigning a Clock to the clock constructor kwarg, which will be used to determine the next bar to stream when calling receive on this broker.\n\n\n\n\n\n","category":"type"},{"location":"trader/#Trading.MockBroker","page":"Trader","title":"Trading.MockBroker","text":"MockBroker\n\nMimics all function of a normal broker but with random data.\n\n\n\n\n\n","category":"type"}]
}
